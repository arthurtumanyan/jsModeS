{"version": 3, "mappings": "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", "sources": ["test2.py"], "names": ["msgbin0", "common", "common.hex2bin", "msg0", "msgbin1", "msg1", "cprlat_even", "common.bin2int", "cprlon_even", "cprlat_odd", "cprlon_odd", "air_d_lat_even", "air_d_lat_odd", "j", "common.floor", "lat_even_n", "lat_odd_n", "lat_even_s", "lat_odd_s", "lat_even", "lat_ref", "lat_odd", "common.cprNL", "t0", "t1", "lat", "nl", "ni", "max", "m", "lon", "lons", "dls", "imin", "min", "range", "dls.__getitem__", "round", "mb", "msg", "cprlat", "cprlon", "i", "$lat", "$lon", "lon_ref"], "sourcesContent": ["# ------------------------------------------\n#   BDS 0,6\n#   ADS-B TC=5-8\n#   Surface movment\n# ------------------------------------------\n\nfrom pyModeS import common\n\n\ndef surface_position(msg0, msg1, t0, t1, lat_ref, lon_ref):\n    \"\"\"Decode surface position from a pair of even and odd position message,\n    the lat/lon of receiver must be provided to yield the correct solution.\n\n    Args:\n        msg0 (string): even message (28 hexdigits)\n        msg1 (string): odd message (28 hexdigits)\n        t0 (int): timestamps for the even message\n        t1 (int): timestamps for the odd message\n        lat_ref (float): latitude of the receiver\n        lon_ref (float): longitude of the receiver\n\n    Returns:\n        (float, float): (latitude, longitude) of the aircraft\n    \"\"\"\n\n    msgbin0 = common.hex2bin(msg0)\n    msgbin1 = common.hex2bin(msg1)\n\n    # 131072 is 2^17, since CPR lat and lon are 17 bits each.\n    cprlat_even = common.bin2int(msgbin0[54:71]) / 131072\n    cprlon_even = common.bin2int(msgbin0[71:88]) / 131072\n    cprlat_odd = common.bin2int(msgbin1[54:71]) / 131072\n    cprlon_odd = common.bin2int(msgbin1[71:88]) / 131072\n\n    air_d_lat_even = 90 / 60\n    air_d_lat_odd = 90 / 59\n\n    # compute latitude index 'j'\n    j = common.floor(59 * cprlat_even - 60 * cprlat_odd + 0.5)\n\n    # solution for north hemisphere\n    lat_even_n = float(air_d_lat_even * (j % 60 + cprlat_even))\n    lat_odd_n = float(air_d_lat_odd * (j % 59 + cprlat_odd))\n\n    # solution for north hemisphere\n    lat_even_s = lat_even_n - 90\n    lat_odd_s = lat_odd_n - 90\n\n    # chose which solution corrispondes to receiver location\n    lat_even = lat_even_n if lat_ref > 0 else lat_even_s\n    lat_odd = lat_odd_n if lat_ref > 0 else lat_odd_s\n\n    # check if both are in the same latidude zone, rare but possible\n    if common.cprNL(lat_even) != common.cprNL(lat_odd):\n        return None\n\n    # compute ni, longitude index m, and longitude\n    if t0 > t1:\n        lat = lat_even\n        nl = common.cprNL(lat_even)\n        ni = max(common.cprNL(lat_even) - 0, 1)\n        m = common.floor(cprlon_even * (nl - 1) - cprlon_odd * nl + 0.5)\n        lon = (90 / ni) * (m % ni + cprlon_even)\n    else:\n        lat = lat_odd\n        nl = common.cprNL(lat_odd)\n        ni = max(common.cprNL(lat_odd) - 1, 1)\n        m = common.floor(cprlon_even * (nl - 1) - cprlon_odd * nl + 0.5)\n        lon = (90 / ni) * (m % ni + cprlon_odd)\n\n    # four possible longitude solutions\n    lons = [lon, lon + 90, lon + 180, lon + 270]\n\n    # make sure lons are between -180 and 180\n    lons = [(l + 180) % 360 - 180 for l in lons]\n\n    # the closest solution to receiver is the correct one\n    dls = [abs(lon_ref - l) for l in lons]\n    imin = min(range(4), key=dls.__getitem__)\n    lon = lons[imin]\n\n    return round(lat, 5), round(lon, 5)\n\n\ndef surface_position_with_ref(msg, lat_ref, lon_ref):\n    \"\"\"Decode surface position with only one message,\n    knowing reference nearby location, such as previously calculated location,\n    ground station, or airport location, etc. The reference position shall\n    be with in 45NM of the true position.\n\n    Args:\n        msg (str): even message (28 hexdigits)\n        lat_ref: previous known latitude\n        lon_ref: previous known longitude\n\n    Returns:\n        (float, float): (latitude, longitude) of the aircraft\n    \"\"\"\n\n    mb = common.hex2bin(msg)[32:]\n\n    cprlat = common.bin2int(mb[22:39]) / 131072\n    cprlon = common.bin2int(mb[39:56]) / 131072\n\n    i = int(mb[21])\n    d_lat = 90 / 59 if i else 90 / 60\n\n    j = common.floor(lat_ref / d_lat) + common.floor(\n        0.5 + ((lat_ref % d_lat) / d_lat) - cprlat\n    )\n\n    lat = d_lat * (j + cprlat)\n\n    ni = common.cprNL(lat) - i\n\n    if ni > 0:\n        d_lon = 90 / ni\n    else:\n        d_lon = 90\n\n    m = common.floor(lon_ref / d_lon) + common.floor(\n        0.5 + ((lon_ref % d_lon) / d_lon) - cprlon\n    )\n\n    lon = d_lon * (m + cprlon)\n\n    return round(lat, 5), round(lon, 5)\n\n\n"]}